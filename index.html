<!DOCTYPE html>
<html>

<head>
  <meta charset=utf-8 />
  <title>Europe &amp; Human Trafficking</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Bree+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">

  <link rel="stylesheet" href="simplegallery.css" />
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
  <script src="jquery.touchSwipe.min.js"></script>

  <script type="text/javascript" src="simplegallery.js">
    /***********************************************
     * Simple Controls Gallery- (c) Dynamic Drive DHTML code library (www.dynamicdrive.com)
     * Please keep this notice intact
     * Visit Dynamic Drive at http://www.dynamicdrive.com/ for this script and 100s more
     ***********************************************/
    var mygallery = new simpleGallery({
      wrapperid: "simplegallery1", //ID of main gallery container,
      dimensions: [250, 180], //width/height of gallery in [pixels, pixels] or ['percentage%', pixels]
      imagearray: [
        ["images/Stop.jpg"],
        ["images/Types.jpg"],
        ["images/Walk.jpg"],
        ["images/Branded.jpg"],
        ["images/30Seconds.jpg"],
        ["images/MouthCover.jpg"],
        ["images/NotForSale.jpg"],
        ["images/Tied.jpg"],
      ],
      autoplay: [true, 2500, 2], //[auto_play_boolean, delay_btw_slide_millisec, cycles_before_stopping_int]
      persist: false,
      scaleimage: 'both', //valid values are 'both', 'width', or 'none'
      fadeduration: 500, //transition duration (milliseconds)
      oninit: function() { //event that fires when gallery has initialized/ ready to run
      },
      onslide: function(curslide, i) { //event that fires after each slide is shown
        //curslide: returns DOM reference to current slide's DIV (ie: try alert(curslide.innerHTML)
        //i: integer reflecting current image within collection being shown (0=1st image, 1=2nd etc)
      }
    })
  </script>

  <script type="text/javascript">
  </script>
  <style>
    /* custom styles here */

    body {
      font-family: "Raleway", serif;
      color: #e34a33;
    }

    h1 {
      font-size: 1.2em;
    }

    h2 {
      font-size: 1.1em;
    }

    #side-col {
      position: absolute;
      width: 25%;
      left: 18px;
      top: 100px;
      bottom: 20px;
      background: #333;
      z-index: 999;
      overflow-y: scroll;
      padding: 18px 12px;
    }

    #map {
      position: absolute;
      width: 100%;
      top: 0;
      bottom: 0;
    }

    #ui {
      position: absolute;
      top: 8px;
      right: 18px;
      z-index: 999;
      background: white;
      width: 120px;
      height: 130px;
    }
  </style>
</head>

<body>

  <div id="side-col">
    <h1>Europe &amp; Human Trafficking</h1>
    <h2>Click on a country to see which other countries in Europe that country trafficks to.</h2>
    <p>Turnip greens yarrow ricebean rutabaga endive cauliflower sea lettuce kohlrabi amaranth water spinach avocado daikon napa cabbage asparagus winter purslane kale. Celery potato scallion desert raisin horseradish spinach carrot soko. Lotus root water
      spinach fennel kombu maize bamboo shoot green bean swiss chard seakale pumpkin onion chickpea gram corn pea. Brussels sprout coriander water chestnut gourd swiss chard wakame kohlrabi beetroot carrot watercress. Corn amaranth salsify bunya nuts
      nori azuki bean chickweed potato bell pepper artichoke.</p>
    <div id="simplegallery1" class="simplegallery"></div>
  </div>
  </div>

  <div id="map"></div>

  <div id='legend' class='bg-gray-dark round px12 py12 relative'>
    <h3 class='txt-bold mb12 w180'>Number of trafficking victims & GDP PPP</h3>
    <div class='legend-circles relative w180'>
      <div class="legend-large border border--gray-light absolute"></div>
      <div class="legend-small border border--gray-light absolute"></div>
      <h3><div class="legend-large-label txt-m absolute"></div></h3>
      <h3><div class="legend-small-label txt-m absolute"></div></h3>
    </div>
  </div>

  <!-- <div id="ui">
    <form>
        <div>
          <input type="radio" id=""
            name="contact" value="gdp">
          <label for="gdp">GDP Layer</label>

          <input type="radio" id=""
            name="contact" value="flow">
          <label for="flowmap">FLowmap</label>
        </div>
      </form>
  </div> -->


  <script src="https://d3js.org/d3-dsv.v1.min.js"></script>
  <script src="https://d3js.org/d3-fetch.v1.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.slim.js"></script>

  <!-- load animation tweening lib requirement for CanvasFlowMapLayer -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.2.0/Tween.min.js"></script>
  <script src="js/CanvasFlowmapLayer.js"></script>
  <script>
    var options = {
      zoomSnap: 1,
      center: [52.805, 1],
      zoom: 4,
      minZoom: 3,
      maxZoom: 6,
    }
    var map = L.map('map', options)
    var OpenStreetMap_Mapnik = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png', {
      // attribute here
    }).addTo(map)

    var flowLayer,
      gdpLayer

    var layerMap = {
      gdp: gdpLayer,
      flow: flowLayer
    };


    // load CSV data
    var trafficData = d3.csv('data/Trafficking_Europe.csv')
    var gdpData = d3.csv('data/PopGDP.csv')

    Promise.all([trafficData, gdpData]).then(dataReady)

    function dataReady(data) {

      var trafficData = data[0],
        gdpData = data[1]

      drawGDPMap(gdpData)
      drawFlowMap(trafficData)
      // makeUI()
    }

    function drawFlowMap(data) {
      // create a new GeoJSON feature collection
      var geojson = {
        "type": "FeatureCollection",
        "features": []
      }
      // loop through the CSV data to build GeoJSON
      data.forEach(function(datum) {
        // create a new Point feature
        var feature = {
          "type": "Feature",
          "geometry": {
            "type": "Point",
            "coordinates": [+datum.source_lon, +datum.source_lat]
          },
          "properties": {
            "origin_id": datum.source_ISO,
            "origin_country": datum.source_name,
            "origin_lon": +datum.source_lon,
            "origin_lat": +datum.source_lat,
            "destination_id": datum.dest_ISO,
            "destination_lon": +datum.dest_lon,
            "destination_lat": +datum.dest_lat,
            "weight": +datum.weight
          }
        }
        // push new feature to GeoJSON collection
        geojson.features.push(feature)
      })
      // L.geoJson(geojson).addTo(map)
      flowLayer = L.canvasFlowmapLayer(geojson, {
        style: function(feature) {
          return {
            weight: feature.properties.weight * .2,
            fillOpacity: 0
          }
        },
        originAndDestinationFieldIds: {
          originUniqueIdField: 'origin_id',
          originGeometry: {
            x: 'origin_lon',
            y: 'origin_lat'
          },
          destinationUniqueIdField: 'destination_id',
          destinationGeometry: {
            x: 'destination_lon',
            y: 'destination_lat'
          }
        },
        // some custom options
        pathDisplayMode: 'selection',
        animationStarted: true,
        animationEasingFamily: 'Cubic',
        animationEasingType: 'In',
        animationDuration: 2000
      }).addTo(map)
      flowLayer.on('click', function(e) {
        if (e.sharedOriginFeatures.length) {
          flowLayer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
        }
        if (e.sharedDestinationFeatures.length) {
          flowLayer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
        }
      });
      // select BG first and show path
      flowLayer.selectFeaturesForPathDisplayById('origin_id', "RU", true, 'SELECTION_NEW');
    }
    var mygallery = new simpleGallery({
      wrapperid: "simplegallery1", //ID of main gallery container,
      dimensions: [362, 210], //width/height of gallery in [pixels, pixels] or ['percentage%', pixels]
      imagearray: [
        ["images/Stop.jpg"],
        ["images/Types.jpg"],
        ["images/Walk.jpg"],
        ["images/Branded.jpg"],
        ["images/30Seconds.jpg"],
        ["images/MouthCover.jpg"],
        ["images/NotForSale.jpg"],
        ["images/Tied.jpg"],
      ],
      autoplay: [true, 2500, 2], //[auto_play_boolean, delay_btw_slide_millisec, cycles_before_stopping_int]
      persist: false,
      scaleimage: 'both', //valid values are 'both', 'width', or 'none'
      fadeduration: 500, //transition duration (milliseconds)
      oninit: function() { //event that fires when gallery has initialized/ ready to run
        //Keyword "this": references current gallery instance (ie: try this.navigate("play/pause")
      },
      onslide: function(curslide, i) { //event that fires after each slide is shown
        //Keyword "this": references current gallery instance (ie: try this.navigate("play/pause")
        //curslide: returns DOM reference to current slide's DIV (ie: try alert(curslide.innerHTML)
        //i: integer reflecting current image within collection being shown (0=1st image, 1=2nd etc)
      }
    })

    function drawGDPMap(data) {
      // create a new GeoJSON feature collection
      var geojson = {
        "type": "FeatureCollection",
        "features": []
      }
      data.forEach(function(datum) {
        // create a new Point feature
        var feature = {
          "type": "Feature",
          "geometry": {
            "type": "Point",
            "coordinates": [+datum.long, +datum.lat]
          },
          "properties": datum
        }
        geojson.features.push(feature);
      }) // end forEach loop
      gdpLayer = L.geoJson(geojson, {
        pointToLayer: function(feature, ll) {
          return L.circleMarker(ll, {
            color: "cyan",
            weight: 1,
            fillOpacity: 0,
            radius: calcRadius(feature.properties.GDP)
          })
        }
      }).addTo(map)
      L.geoJson(geojson, {
        pointToLayer: function(feature, ll) {
          return L.circleMarker(ll, {
            color: "red",
            weight: 1,
            fillOpacity: 0,
            radius: calcRadius(feature.properties.Number_Slavery)
          })
        }
        //Add tooltip?
        /*  onEachFeature: function(feature, ll) {

            layer.bindTooltip(feature.properties.Country_Name);
          }
          // when mousing over a layer
          layer.on('mouseover', function() {

            // change the stroke color and bring that element to the front
            layer.setStyle({
              color: '#ff6e00'
            }).bringToFront();
          });

          // on mousing off layer
          layer.on('mouseout', function() {

            // reset the layer style to its original stroke color
            layer.setStyle({
              color: '#dddddd'
            });
          });
        }*/
      }).addTo(map)
    }

    function calcRadius(val) {
      var radius = Math.sqrt(val / Math.PI);
      return radius * .15;
    }

    function makeUI() {
      var layerControl = {
        "gdp": gdpLayer,
        "flow": flowLayer
      }
      L.control.layers(layerControl, {
        // collapsed: true
      }).addTo(map);
      // $("#ui input").change(function() {
      //   var selection = this.value
      //   if(selection === 'gdp') {
      //     map.removeLayer(flowLayer)
      //     map.addLayer(gdpLayer)
      //   } else {
      //     map.removeLayer(gdpLayer)
      //     map.addLayer(flowLayer)
      //   }
      // })
    }
  </script>
</body>

</html>
